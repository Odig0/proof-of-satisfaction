{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-936656c4f0fc6768858bc49a53b567ca620afe3e",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/ProofOfFun.sol": "project/contracts/ProofOfFun.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ],
      "viaIR": true
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Pausable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/ProofOfFun.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\r\n\r\n/**\r\n * @title ProofOfFun\r\n * @dev Anonymous blockchain voting system for event feedback\r\n * @notice This contract enables anonymous voting on multiple categories while maintaining transparency\r\n */\r\ncontract ProofOfFun is Ownable, ReentrancyGuard, Pausable {\r\n    \r\n    // ============ Structs ============\r\n    \r\n    struct Category {\r\n        string name;\r\n        bool isActive;\r\n        uint256 totalVotes;\r\n        mapping(uint8 => uint256) voteCounts; // rating (1-5) => count\r\n    }\r\n    \r\n    struct Event {\r\n        string name;\r\n        string description;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        bool isActive;\r\n        uint256[] categoryIds;\r\n        mapping(uint256 => bool) hasCategory;\r\n        mapping(address => bool) hasVoted;\r\n        mapping(address => mapping(uint256 => bool)) hasVotedCategory;\r\n        uint256 totalParticipants;\r\n    }\r\n    \r\n    struct VoteProof {\r\n        bytes32 voteHash;\r\n        uint256 timestamp;\r\n        uint256 eventId;\r\n        uint256 categoryId;\r\n    }\r\n    \r\n    struct CategoryResult {\r\n        string name;\r\n        uint256 average; // Scaled by 100 (e.g., 425 = 4.25)\r\n        uint256 totalVotes;\r\n        uint256[5] distribution; // Count for each rating 1-5\r\n    }\r\n    \r\n    // ============ State Variables ============\r\n    \r\n    uint256 public nextEventId;\r\n    uint256 public nextCategoryId;\r\n    uint256 public constant MIN_RATING = 1;\r\n    uint256 public constant MAX_RATING = 5;\r\n    uint256 public constant PRECISION = 100; // For average calculation\r\n    \r\n    mapping(uint256 => Event) public events;\r\n    mapping(uint256 => Category) public categories;\r\n    mapping(bytes32 => VoteProof) public voteProofs;\r\n    mapping(address => uint256) public userVoteCount;\r\n    \r\n    // ============ Events ============\r\n    \r\n    event EventCreated(uint256 indexed eventId, string name, uint256 startTime, uint256 endTime);\r\n    event EventUpdated(uint256 indexed eventId, string name, uint256 startTime, uint256 endTime);\r\n    event EventStatusChanged(uint256 indexed eventId, bool isActive);\r\n    event CategoryCreated(uint256 indexed categoryId, string name);\r\n    event CategoryUpdated(uint256 indexed categoryId, string name);\r\n    event CategoryStatusChanged(uint256 indexed categoryId, bool isActive);\r\n    event VoteCast(uint256 indexed eventId, uint256 indexed categoryId, bytes32 voteHash, uint256 timestamp);\r\n    event VoteRevoked(uint256 indexed eventId, address indexed voter);\r\n    event ResultsPublished(uint256 indexed eventId, uint256 timestamp);\r\n    \r\n    // ============ Errors ============\r\n    \r\n    error InvalidRating();\r\n    error InvalidCategory();\r\n    error InvalidEvent();\r\n    error EventNotActive();\r\n    error EventNotStarted();\r\n    error EventEnded();\r\n    error AlreadyVoted();\r\n    error CategoryNotInEvent();\r\n    error NoVotesRecorded();\r\n    error Unauthorized();\r\n    \r\n    // ============ Constructor ============\r\n    \r\n    constructor() Ownable(msg.sender) {\r\n        // Initialize default categories\r\n        _createCategory(\"Ambience\");\r\n        _createCategory(\"Organization\");\r\n        _createCategory(\"Content\");\r\n        _createCategory(\"Technology\");\r\n        _createCategory(\"Entertainment\");\r\n        _createCategory(\"Accessibility\");\r\n    }\r\n    \r\n    // ============ Category Management ============\r\n    \r\n    function _createCategory(string memory _name) internal returns (uint256) {\r\n        uint256 categoryId = nextCategoryId++;\r\n        Category storage category = categories[categoryId];\r\n        category.name = _name;\r\n        category.isActive = true;\r\n        category.totalVotes = 0;\r\n        \r\n        emit CategoryCreated(categoryId, _name);\r\n        return categoryId;\r\n    }\r\n    \r\n    function createCategory(string memory _name) external onlyOwner returns (uint256) {\r\n        return _createCategory(_name);\r\n    }\r\n    \r\n    function updateCategory(uint256 _categoryId, string memory _name) external onlyOwner {\r\n        if (_categoryId >= nextCategoryId) revert InvalidCategory();\r\n        categories[_categoryId].name = _name;\r\n        emit CategoryUpdated(_categoryId, _name);\r\n    }\r\n    \r\n    function toggleCategoryStatus(uint256 _categoryId) external onlyOwner {\r\n        if (_categoryId >= nextCategoryId) revert InvalidCategory();\r\n        categories[_categoryId].isActive = !categories[_categoryId].isActive;\r\n        emit CategoryStatusChanged(_categoryId, categories[_categoryId].isActive);\r\n    }\r\n    \r\n    function getCategory(uint256 _categoryId) external view returns (string memory name, bool isActive, uint256 totalVotes) {\r\n        if (_categoryId >= nextCategoryId) revert InvalidCategory();\r\n        Category storage category = categories[_categoryId];\r\n        return (category.name, category.isActive, category.totalVotes);\r\n    }\r\n    \r\n    function getCategoryVoteDistribution(uint256 _categoryId) external view returns (uint256[5] memory) {\r\n        if (_categoryId >= nextCategoryId) revert InvalidCategory();\r\n        Category storage category = categories[_categoryId];\r\n        uint256[5] memory distribution;\r\n        for (uint8 i = 0; i < 5; i++) {\r\n            distribution[i] = category.voteCounts[i + 1];\r\n        }\r\n        return distribution;\r\n    }\r\n    \r\n    // ============ Event Management ============\r\n    \r\n    function createEvent(\r\n        string memory _name,\r\n        string memory _description,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        uint256[] memory _categoryIds\r\n    ) external onlyOwner returns (uint256) {\r\n        require(_startTime < _endTime, \"Invalid time range\");\r\n        require(_categoryIds.length > 0, \"No categories provided\");\r\n        \r\n        uint256 eventId = nextEventId++;\r\n        Event storage newEvent = events[eventId];\r\n        newEvent.name = _name;\r\n        newEvent.description = _description;\r\n        newEvent.startTime = _startTime;\r\n        newEvent.endTime = _endTime;\r\n        newEvent.isActive = true;\r\n        newEvent.totalParticipants = 0;\r\n        \r\n        // Add categories to event\r\n        for (uint256 i = 0; i < _categoryIds.length; i++) {\r\n            uint256 catId = _categoryIds[i];\r\n            if (catId >= nextCategoryId) revert InvalidCategory();\r\n            if (!categories[catId].isActive) revert InvalidCategory();\r\n            \r\n            newEvent.categoryIds.push(catId);\r\n            newEvent.hasCategory[catId] = true;\r\n        }\r\n        \r\n        emit EventCreated(eventId, _name, _startTime, _endTime);\r\n        return eventId;\r\n    }\r\n    \r\n    function updateEvent(\r\n        uint256 _eventId,\r\n        string memory _name,\r\n        string memory _description,\r\n        uint256 _startTime,\r\n        uint256 _endTime\r\n    ) external onlyOwner {\r\n        if (_eventId >= nextEventId) revert InvalidEvent();\r\n        require(_startTime < _endTime, \"Invalid time range\");\r\n        \r\n        Event storage eventData = events[_eventId];\r\n        eventData.name = _name;\r\n        eventData.description = _description;\r\n        eventData.startTime = _startTime;\r\n        eventData.endTime = _endTime;\r\n        \r\n        emit EventUpdated(_eventId, _name, _startTime, _endTime);\r\n    }\r\n    \r\n    function toggleEventStatus(uint256 _eventId) external onlyOwner {\r\n        if (_eventId >= nextEventId) revert InvalidEvent();\r\n        events[_eventId].isActive = !events[_eventId].isActive;\r\n        emit EventStatusChanged(_eventId, events[_eventId].isActive);\r\n    }\r\n    \r\n    function getEvent(uint256 _eventId) external view returns (\r\n        string memory name,\r\n        string memory description,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        bool isActive,\r\n        uint256 totalParticipants,\r\n        uint256[] memory categoryIds\r\n    ) {\r\n        if (_eventId >= nextEventId) revert InvalidEvent();\r\n        Event storage eventData = events[_eventId];\r\n        return (\r\n            eventData.name,\r\n            eventData.description,\r\n            eventData.startTime,\r\n            eventData.endTime,\r\n            eventData.isActive,\r\n            eventData.totalParticipants,\r\n            eventData.categoryIds\r\n        );\r\n    }\r\n    \r\n    // ============ Voting Functions ============\r\n    \r\n    function vote(\r\n        uint256 _eventId,\r\n        uint256 _categoryId,\r\n        uint8 _rating,\r\n        bytes32 _salt\r\n    ) external nonReentrant whenNotPaused {\r\n        // Validations\r\n        if (_eventId >= nextEventId) revert InvalidEvent();\r\n        if (_categoryId >= nextCategoryId) revert InvalidCategory();\r\n        if (_rating < MIN_RATING || _rating > MAX_RATING) revert InvalidRating();\r\n        \r\n        Event storage eventData = events[_eventId];\r\n        \r\n        if (!eventData.isActive) revert EventNotActive();\r\n        if (block.timestamp < eventData.startTime) revert EventNotStarted();\r\n        if (block.timestamp > eventData.endTime) revert EventEnded();\r\n        if (!eventData.hasCategory[_categoryId]) revert CategoryNotInEvent();\r\n        if (eventData.hasVotedCategory[msg.sender][_categoryId]) revert AlreadyVoted();\r\n        \r\n        // Generate anonymous vote hash\r\n        bytes32 voteHash = keccak256(abi.encodePacked(\r\n            msg.sender,\r\n            _eventId,\r\n            _categoryId,\r\n            _rating,\r\n            _salt,\r\n            block.timestamp\r\n        ));\r\n        \r\n        // Record vote anonymously\r\n        Category storage category = categories[_categoryId];\r\n        category.voteCounts[_rating]++;\r\n        category.totalVotes++;\r\n        \r\n        // Mark as voted\r\n        eventData.hasVotedCategory[msg.sender][_categoryId] = true;\r\n        \r\n        // Track if first vote from user for this event\r\n        if (!eventData.hasVoted[msg.sender]) {\r\n            eventData.hasVoted[msg.sender] = true;\r\n            eventData.totalParticipants++;\r\n        }\r\n        \r\n        // Store vote proof\r\n        VoteProof storage proof = voteProofs[voteHash];\r\n        proof.voteHash = voteHash;\r\n        proof.timestamp = block.timestamp;\r\n        proof.eventId = _eventId;\r\n        proof.categoryId = _categoryId;\r\n        \r\n        userVoteCount[msg.sender]++;\r\n        \r\n        emit VoteCast(_eventId, _categoryId, voteHash, block.timestamp);\r\n    }\r\n    \r\n    function batchVote(\r\n        uint256 _eventId,\r\n        uint256[] memory _categoryIds,\r\n        uint8[] memory _ratings,\r\n        bytes32 _salt\r\n    ) external nonReentrant whenNotPaused {\r\n        require(_categoryIds.length == _ratings.length, \"Array length mismatch\");\r\n        require(_categoryIds.length > 0, \"Empty arrays\");\r\n        \r\n        if (_eventId >= nextEventId) revert InvalidEvent();\r\n        \r\n        Event storage eventData = events[_eventId];\r\n        if (!eventData.isActive) revert EventNotActive();\r\n        if (block.timestamp < eventData.startTime) revert EventNotStarted();\r\n        if (block.timestamp > eventData.endTime) revert EventEnded();\r\n        \r\n        for (uint256 i = 0; i < _categoryIds.length; i++) {\r\n            uint256 categoryId = _categoryIds[i];\r\n            uint8 rating = _ratings[i];\r\n            \r\n            if (categoryId >= nextCategoryId) revert InvalidCategory();\r\n            if (rating < MIN_RATING || rating > MAX_RATING) revert InvalidRating();\r\n            if (!eventData.hasCategory[categoryId]) revert CategoryNotInEvent();\r\n            if (eventData.hasVotedCategory[msg.sender][categoryId]) revert AlreadyVoted();\r\n            \r\n            // Generate anonymous vote hash\r\n            bytes32 voteHash = keccak256(abi.encodePacked(\r\n                msg.sender,\r\n                _eventId,\r\n                categoryId,\r\n                rating,\r\n                _salt,\r\n                block.timestamp,\r\n                i // Include index for uniqueness\r\n            ));\r\n            \r\n            // Record vote anonymously\r\n            Category storage category = categories[categoryId];\r\n            category.voteCounts[rating]++;\r\n            category.totalVotes++;\r\n            \r\n            // Mark as voted\r\n            eventData.hasVotedCategory[msg.sender][categoryId] = true;\r\n            \r\n            // Store vote proof\r\n            VoteProof storage proof = voteProofs[voteHash];\r\n            proof.voteHash = voteHash;\r\n            proof.timestamp = block.timestamp;\r\n            proof.eventId = _eventId;\r\n            proof.categoryId = categoryId;\r\n            \r\n            emit VoteCast(_eventId, categoryId, voteHash, block.timestamp);\r\n        }\r\n        \r\n        // Track participant (only once per event)\r\n        if (!eventData.hasVoted[msg.sender]) {\r\n            eventData.hasVoted[msg.sender] = true;\r\n            eventData.totalParticipants++;\r\n        }\r\n        \r\n        userVoteCount[msg.sender] += _categoryIds.length;\r\n    }\r\n    \r\n    // ============ Results Calculation ============\r\n    \r\n    function calculateCategoryAverage(uint256 _categoryId) public view returns (uint256) {\r\n        if (_categoryId >= nextCategoryId) revert InvalidCategory();\r\n        \r\n        Category storage category = categories[_categoryId];\r\n        if (category.totalVotes == 0) revert NoVotesRecorded();\r\n        \r\n        uint256 weightedSum = 0;\r\n        for (uint8 rating = 1; rating <= MAX_RATING; rating++) {\r\n            weightedSum += category.voteCounts[rating] * rating;\r\n        }\r\n        \r\n        // Return average scaled by PRECISION (e.g., 425 = 4.25)\r\n        return (weightedSum * PRECISION) / category.totalVotes;\r\n    }\r\n    \r\n    function getEventResults(uint256 _eventId) external view returns (CategoryResult[] memory) {\r\n        if (_eventId >= nextEventId) revert InvalidEvent();\r\n        \r\n        Event storage eventData = events[_eventId];\r\n        uint256 categoryCount = eventData.categoryIds.length;\r\n        CategoryResult[] memory results = new CategoryResult[](categoryCount);\r\n        \r\n        for (uint256 i = 0; i < categoryCount; i++) {\r\n            uint256 catId = eventData.categoryIds[i];\r\n            Category storage category = categories[catId];\r\n            \r\n            results[i].name = category.name;\r\n            results[i].totalVotes = category.totalVotes;\r\n            \r\n            if (category.totalVotes > 0) {\r\n                results[i].average = calculateCategoryAverage(catId);\r\n                \r\n                // Get distribution\r\n                for (uint8 rating = 1; rating <= MAX_RATING; rating++) {\r\n                    results[i].distribution[rating - 1] = category.voteCounts[rating];\r\n                }\r\n            }\r\n        }\r\n        \r\n        return results;\r\n    }\r\n    \r\n    function publishResults(uint256 _eventId) external onlyOwner {\r\n        if (_eventId >= nextEventId) revert InvalidEvent();\r\n        Event storage eventData = events[_eventId];\r\n        \r\n        require(block.timestamp > eventData.endTime, \"Event not ended\");\r\n        \r\n        emit ResultsPublished(_eventId, block.timestamp);\r\n    }\r\n    \r\n    // ============ Query Functions ============\r\n    \r\n    function hasUserVoted(uint256 _eventId, address _user) external view returns (bool) {\r\n        if (_eventId >= nextEventId) revert InvalidEvent();\r\n        return events[_eventId].hasVoted[_user];\r\n    }\r\n    \r\n    function hasUserVotedCategory(uint256 _eventId, address _user, uint256 _categoryId) external view returns (bool) {\r\n        if (_eventId >= nextEventId) revert InvalidEvent();\r\n        if (_categoryId >= nextCategoryId) revert InvalidCategory();\r\n        return events[_eventId].hasVotedCategory[_user][_categoryId];\r\n    }\r\n    \r\n    function getActiveCategories() external view returns (uint256[] memory) {\r\n        uint256 activeCount = 0;\r\n        \r\n        // Count active categories\r\n        for (uint256 i = 0; i < nextCategoryId; i++) {\r\n            if (categories[i].isActive) {\r\n                activeCount++;\r\n            }\r\n        }\r\n        \r\n        // Build array of active category IDs\r\n        uint256[] memory activeCategories = new uint256[](activeCount);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < nextCategoryId; i++) {\r\n            if (categories[i].isActive) {\r\n                activeCategories[index] = i;\r\n                index++;\r\n            }\r\n        }\r\n        \r\n        return activeCategories;\r\n    }\r\n    \r\n    function getActiveEvents() external view returns (uint256[] memory) {\r\n        uint256 activeCount = 0;\r\n        \r\n        // Count active events\r\n        for (uint256 i = 0; i < nextEventId; i++) {\r\n            if (events[i].isActive) {\r\n                activeCount++;\r\n            }\r\n        }\r\n        \r\n        // Build array of active event IDs\r\n        uint256[] memory activeEvents = new uint256[](activeCount);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < nextEventId; i++) {\r\n            if (events[i].isActive) {\r\n                activeEvents[index] = i;\r\n                index++;\r\n            }\r\n        }\r\n        \r\n        return activeEvents;\r\n    }\r\n    \r\n    // ============ Admin Functions ============\r\n    \r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n    \r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n    \r\n    function getCategoryCount() external view returns (uint256) {\r\n        return nextCategoryId;\r\n    }\r\n    \r\n    function getEventCount() external view returns (uint256) {\r\n        return nextEventId;\r\n    }\r\n}\r\n"
      }
    }
  }
}